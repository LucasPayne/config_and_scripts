# lfrc - lf configuration file
# lf - Terminal file manager
#
# Resources:
#    man 1 lf
#    https://github.com/gokcehan/lf
#    https://github.com/gokcehan/lf/wiki/
#    https://github.com/gokcehan/lf/wiki/Tips
#    https://wiki.archlinux.org/title/Lf

# Default runtime directory (for e.g. selection files).
# Caller can set this manually when running lf with `lf --command=`.
#NOTE: Would prefer to get this from envvar but having trouble with eval and async.
set user_runtime_dir "/run/user/1000/lf"

# Whether to preview readmes when in the focus directory.
set user_readmes 1
# Disable "directory caching".
# Prevents lf from caching preview results, so preview options can change dynamically.
#todo: Does this have other implications?
#NOTE: Apparently yes, this is for some reason preventing
# lf from focusing an argument on startup.
# Commenting it out for now.
#set nodircache

# my_runtime in ~/.local/share/lf.
# This contains runtime data indexed by the lf process id.
# I can configure lf to write out state automatically,
# so external processes which only know the lf's pid can access it.
# TODO: Use eval to expand ~? Eval isn't working.
set user_my_runtime_prefix ".local/share/lf/my_runtime"

# The "launcher file" can be set with -command, or remotely.
# This is an optional context which can be used by keybindings,
# the file which lf was "launched" from.
# e.g. if in vim there is a keybinding to open lf in a popup terminal
# at the file's directory, it makes sense that that file is the "launch file",
# and lf will have a keybinding to return to it.
set user_launcher_file ""
# The "launcher term" is a vim buffer number which can be used
# with vim remote commands, such as caling term_sendkeys.
# This is -1 by default, but can be set by a -command by the launcher
# if the launcher is from a shell prompt.
# This can be used to use lf as a file argument selector.
set user_launcher_term -1

# White background, black text
#set cursoractivefmt "\033[0;30;47m"
#set cursorparentfmt "\033[0;30;47m"
#set cursorpreviewfmt "\033[0;30;47m"
# Underlined, white text.
#set cursoractivefmt "\033[4;37;40m%s\033[0m"
#set cursorparentfmt "\033[4;37;40m%s\033[0m"
#set cursorpreviewfmt "\033[4;37;40m%s\033[0m"
# Underlined, keep text color.
set cursoractivefmt "\033[4;40m%s\033[0m"
set cursorparentfmt "\033[4;40m%s\033[0m"
set cursorpreviewfmt "\033[4;40m%s\033[0m"


# LF-LANGUAGE UTILITIES
#<<<
#https://github.com/gokcehan/lf/wiki/Tips
# eval: Run an lf command after expanding $ shell syntax (envvars and command substitution).
# lf-language doesn't have an env-var syntax.
# However it can access env-vars from subshells,
# and subshells can send commands to lf.
# So, routing a command line through a subshell
# has the effect of expanding environment variables.
#NOTE: This is run as an async command.
#      It is useless(?) to run blocking as the lf -remote is async itself.
#      So can only use this to spawn "jobs", 
cmd eval &{{
    cmd="send $id"
    for arg; do
        cmd="$cmd $(eval "printf '%s' \"$arg\"" | sed 's/\\/\\\\/g;s/ /\\ /g;s/"/\\"/g')"
    done
    lf -remote "$cmd"
}}
#>>>

# EVENT HOOKS
#<<<

#Waiting for release 34 for on-init
#cmd on-init ${{
#    $load-selection
#    #$load-focus
#}}

cmd on-select :{{
    &save-focus
}}
#-doesn't appear to help
#cmd on-select &{{
#    lf -remote "send $id save-focus; redraw"
#}}
cmd on-quit :{{
    $save-selection
    $save-focus
}}
#-This doesn't appear to be working in my usual setup.
# In VS code terminal, it looks like it is continuously called...
# Also combined with flickering, is load-selection causing a flicker
# which also causes focus to gain again?
#cmd on-focus-gained :{{
#    &load-selection
#}}

cmd my-runtime-cwd &{{
    runtime="$(my_runtime)"
    echo "$PWD" > "$runtime/cwd"
    if in_vim
    then
        vim_remote_call RedrawTabPanel
    fi
}}

#Waiting for r34 for on-init.
# cmd on-init my-runtime-cwd
cmd on-cd my-runtime-cwd

#>>>

# LF COMMAND OVERRIDES (open, etc.)
#<<<
cmd open :LFRC::open-file
#>>>

# BASIC COMMANDS
#<<<
# Add more state pagers like the builtins maps, cmaps, and cmds.
# query server-command can request history and jumps.
cmd history $lf -remote "query $id history" | $PAGER
cmd jumps $lf -remote "query $id jumps" | $PAGER
# query server-command does not currently have an "options" option, so do this using lf_* envvars.
cmd options ${{
    env | grep ^lf_ | while read -r line ;
    do
        # Convert lf_<option>=<value> env output to a more readable form.
        if [[ $line =~ ^lf_([^=]+)=(.*)$ ]]
        then
            option="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            printf '%s = %s\n' "$option" "$value"
        fi
    done | $PAGER
}}

#>>>

# LF-LANGUAGE LIBRARIES
#<<<
# "Link" to lfrc_lib.lfso "library".
# This allows lf config to be spread across multiple files.
# lfrc_lib/Makefile will generate this "library" from .lf files.
# note: If lf language had wildcards this would be easier.
# note: This is currently run async so functions might not be loaded in initialization...
eval source "$CONFIG_DIR/lf/lfrc_lib/build/lfrc_lib.lfso"
#>>>

# OPTIONS
#<<<
set shell bash
eval set previewer "$CONFIG_DIR/lf/previewer.sh"
#todo:?
set ifs ' '
set nodrawbox
set noicons
set ignorecase
set mouse
set sortby natural
set info
# Jump to the next search match while typing.
set incsearch
# Show results in filter mode.
set incfilter
# Use globs in filter mode.
#-Why is this normal searches fail? Shouldn't searches with non-glob chars be the same as before?
#set globfilter
# Preview directories
set dirpreviews
#>>>

# MAPPINGS
#<<<
# Filtering <<<
map f :set user_filter_mode "filter"; filter
map F :set user_filter_mode "filter-find"; filter; cmd-end; cmd-delete-home
map U setfilter
cmap <a-\;> :cmd-enter; setfilter; LFRC::open
# Search
cmd lf_search ${{
    search_dir="$(fd | bash ~/config/lf/lf_search.sh)"
    lf -remote "send $id cd $(printf '%q' "$search_dir")"
    lf -remote "send $id set ratios 4:3"
}}
map <a-/> :lf_search

cmap <enter> &{{
    echo "$lf_user_filter_mode" > /tmp/a
    echo "$lf_mode" >> /tmp/a
    if [ "$lf_mode" = filter ]
    then
        case "$lf_user_filter_mode" in
            filter-find)
                lf -remote "send $id :cmd-enter; setfilter; open_enter 1"
                echo benis >/tmp/a
                ;;
            filter)
                lf -remote "send $id :cmd-enter"
                ;;
        esac
    else
        lf -remote "send $id cmd-enter"
    fi
}}

# View selection in a pager.
map <a-s> $cat "$lf_user_runtime_dir/$lf_user_selection_file" | $PAGER

# Select filtered files.
# Overrides filter mode.
cmap <a-s> &{{
    if [ "$lf_mode" = filter ]
    then
        lf -remote "send $id :cmd-enter; glob-select *; on-selection-changed; setfilter"
    fi
}}

cmap <a-j> &{{
    if [ "$lf_mode" = filter ]
    then
        lf -remote "send $id down"
    fi
}}
cmap <a-k> &{{
    if [ "$lf_mode" = filter ]
    then
        lf -remote "send $id up"
    fi
}}

#>>>
# System mappings<<<
# Make Ctrl-Z work as SIGTSTP as usual.
#https://github.com/gokcehan/lf/issues/357
map <c-z> $ kill -TSTP $PPID
cmap <c-z> $ kill -TSTP $PPID
# Ctrl-C to quit.
map <c-c> quit
# Also Alt-x to quit.
map <a-x> quit
# Default: Ctrl-C in command mode cancels the command.
# Also Alt-x to cancel command.
cmap <a-x> cmd-interrupt
#>>>
# z (info and ordering) mappings <<<
#
# Defaults:
# z a: map za set info size:time
# z h: map zh set hidden!
# z n: map zn set info
# z r: map zr set reverse!
# z s: map zs set info size
# z t: map zt set info time
# Own
#>>>
# s (sorting) mappings <<<
# Defaults
# s n: set sortby natural; set info
# s s: set sortby size; set info size
# s t: set sortby time; set info time
# s a: set sortby atime; set info atime
# s c: set sortby ctime; set info ctime
# s e: set sortby ext; set info
# Own
# s N:
map sN set sortby name; set info
#>>>
# leader-\ mappings <<<
# Leader key: \
map \\b :set drawbox!
# Toggle ratios
# note: This should be in-line with where ratios are set elsewhere.
# idea: Maybe should have a different ratio setting which those functions call.
map \\c ${{
    if [ "$lf_ratios" = "1:2:3" ]
    then
        lf -remote "send $id set ratios 1:2"
    else
        lf -remote "send $id set ratios 1:2:3"
    fi
}}
# Toggle readme previews
#note: Not sure if user_ options are toggleable, and since lf-language has no control flow,
#      am using a subshell with remote commands.
map \\r ${{
    [ "$lf_user_readmes" -eq 1 ] \
        && lf -remote "send $id set user_readmes 0" \
        || lf -remote "send $id set user_readmes 1"
    lf -remote "send $id redraw"
}}
# Preview readme
map \\p ${{
    readme="$(get_readme ".")"
    if [ $? -eq 0 ]
    then
        cat "$readme" | $PAGER
        exit 0
    else
        lf -remote "send $id echoerr \"Could not find readme file in this directory.\""
        exit 1
    fi
}}
#>>>
# Mouse mappings<<<
# Middle click
#todo: middle click to select and toggle
#    Why doesn't this push work? Might be special logic for working with mouse position
#    which no longer works when <m-1> is routed through push.
#map <m-3> push <m-1><space>
#>>>
# Alt mappings <<<
# map <a-m> maps
# map <a-M> cmaps
# Todo: Find new keys to map these to
#map <a-c> cmds
#map <a-C> options
# Open a dirspace. This opens the closest parent if it is not a dirspace.
map <a-n> ${{
    if dirspace_open --parent "$PWD"
    then
        lf -remote "send $id quit"
    fi
}}
# Open a dirspace. If it is not in dirspaces.txt, force it to open anyway.
map <a-N> ${{
    if dirspace_open --force "$PWD"
    then
        lf -remote "send $id quit"
    fi
}}

# Swap between current and last directory.
#todo, for now it's just jump-prev
#map <a-C> jump-prev
# Swap to the vim server's global working directory.
map <a-\;> %{{
    if in_vim
    then
        targetdir="$(vim_remote_call getcwd -1)"
        if [ "$(pwd)" != "$targetdir" ]
        then
            lf -remote "send cd $(printf '%q' "$targetdir")"
        fi
    fi
}}
# Swap to the launch focus file's working directory with it at focus.
map <a-:> %{{
    if [ ! "$lf_user_launcher_file" = "" ]
    then
        if [ -d "$lf_user_launcher_file" ]
        then
            # If it is a directory, instead cd to it.
            lf -remote "send cd $(printf '%q' "$lf_user_launcher_file")"
        else
            lf -remote "send select $(printf '%q' "$lf_user_launcher_file")"
        fi
    fi
}}

map <a-h> LFRC::execute-from-history
# Clear command first.
cmap <a-h> :cmd-end; cmd-delete-home; LFRC::execute-from-history

#>>>
# General mappings
map i $LESSOPEN='| ~/config/lf/previewer.sh %s' less -R $f
map h
map \; open
map l updir
# Unmap e, it defaults to run $EDITOR.
map e
# Use h for : as part of the set of hjkl -> jkl; rebindings.
map h read
map D LFRC::mkdir
map T LFRC::touch
# move faster
map J :down; down; down; down; down; down; down; down
map K :up; up; up; up; up; up; up; up
# Execute file.
# (No arguments)
map <c-x> ${{
    if [ -f "$f" ] && [ -x "$f" ]
    then
        "$f"
        lf -remote "send $id echo \"Executed $f\""
    else
        lf -remote "send $id echoerr \"$f is not executable\""
    fi
}}

cmd yank-dirname ${{
    echo "$PWD" | xclip -i -selection clipboard
}}
cmd yank-path ${{
    printf '%s' "$f" | xclip -i -selection clipboard
}}

# Set wallpaper
cmd wp ${{
    wp "$f"
}}

map <a-f> :LFRC::fzf_jump 0
#map <a-r> :LFRC::fzf_jump 1
map x :LFRC::unarchive
map g :top
# Unmap w. w's default is to close lf.
map w

map <a-y> :yank-path
map <a-Y> :yank-dirname
#map <a-j> :down
#map <a-k> :up

# Checkout navigation, should have same effect as from shell, but uses this existing lf session.
cmd lf-checkout-find-config &lf-checkout-find ~/config
map <a-i> :lf-checkout-find-config

cmd lf-checkout-find-dev &lf-checkout-find ~/drive/dev
map <a-e> :lf-checkout-find-dev

cmd lf-checkout-find-code &lf-checkout-find ~/code
#map <a-q> :lf-checkout-find-code

cmd lf-checkout-find-documentation &lf-checkout-find ~/drive/dev/documentation
map <a-d> :lf-checkout-find-documentation

cmd open &{{
    v "$f"
}}

# Open a text file and go to the end.
# map A &{{
#     # Using -l because it is easy. Assuming the file is < 100000 lines long.
#     v "$f" -l 100000
# }}

#>>>

# VIM MAPPINGS
#<<<
# Open in new tab
map p %Lf_Edit "$f" "tab" 1
map <a-p> %Lf_Edit "$f" "tab" 0
# Open to the left in a vertical split.
map I %Lf_Edit "$f" "left" 1
map <a-I> %Lf_Edit "$f" "left" 0
# Open to the right in a vertical split.
map A %Lf_Edit "$f" "right" 1
map <a-A> %Lf_Edit "$f" "right" 0
# Open below in a horizontal split
map o %Lf_Edit "$f" "down" 1
map <a-o> %Lf_Edit "$f" "down" 0
# Open above in a horizontal split
map O %Lf_Edit "$f" "up" 1
map <a-O> %Lf_Edit "$f" "up" 0
# Open at vim's focus window.
map r %Lf_Edit "$f" "here" 1
map <a-r> %Lf_Edit "$f" "here" 0

# Open terminals
map <a-c><a--> %{{
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call LowerShell "$PWD"
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}
map <a-c><a-r> %{{
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call CurrentShell "$PWD"
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}
map <a-c><a-c> %{{
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call TabShell "$PWD"
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}
map <a-C> %{{
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call MainShell "$PWD"
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}

# General enter key, does multiple things.
cmd open_enter ${{
    close="$1"
    mim="$(mimetype -b "$(realpath "$f")")"
    if in_vim && ( [ "$mim" = "application/x-shellscript" ] || [[ "$mim" =~ ^text/ ]] )
    then
        # vim_remote_call Lf_Edit "$f" "here" "$close"
        vim_remote_call Lf_Edit "$f" "tab" "$close"
    elif [ -d "$f" ]
    then
        if [ $close -eq 1 ]
        then
            # # It doesn't make sense to navigate and lf then close.
            # # So, this option instead opens it in the GUI file browser,
            # # which might be useful.
            # xdg-open "$f"
            # lf -remote "send $id quit"
            #X--
            # Just doing the same, so pressing alt doesn't change anything in this case.
            lf -remote "send $id open"
        else
            lf -remote "send $id open"
        fi
    else
        xdg-open "$f"
        if [ $close -eq 1 ]
        then
            lf -remote "send $id quit"
        fi
    fi
}}
map <enter> :open_enter 1
map <a-enter> :open_enter 0

# Text entry commands.
# If user_launcher_term is set to a vim terminal buffer with an interactive shell foregrounded,
# write the text as an argument, with a space after.
# If launched on a editable vim file buffer, then enter that text.
#
# Write the selected file f
map <a-u> %{{
    if in_vim
    then
        if [ $lf_user_launcher_term -ne -1 ]
        then
            shell_type_keys "$(printf '%q' "$f") "
            lf -remote "send $id quit"
        elif [ ! "$lf_user_launcher_file" = "" ] && [ -f "$lf_user_launcher_file" ]
        then
            # It is assumed that vim has focus on a file.
            vim_remote_call Lf_EnterText "$f" 1
            lf -remote "send $id quit"
        fi
    fi
}}
# Write the current directory
map <a-U> %{{
    if in_vim
    then
        if [ $lf_user_launcher_term -ne -1 ]
        then
            shell_type_keys "$(printf '%q' "$PWD") "
            lf -remote "send $id quit"
        elif [ ! "$lf_user_launcher_file" = "" ] && [ -f "$lf_user_launcher_file" ]
        then
            # It is assumed that vim has focus on a file.
            vim_remote_call Lf_EnterText "$PWD" 1
            lf -remote "send $id quit"
        fi
    fi
}}

# Exit lf and cd to its directory.
# Note: This assumes <c-u> in the shell is bound to delete to the start of the line.
map q %{{
    if in_vim && [ $lf_user_launcher_term -ne -1 ]
    then
        if [ ! "$lf_user_launcher_file" = "$PWD" ]
        then
            vim_remote_call Lf_Popup_BeginIgnore
            vim_remote_expr "Lf_LauncherTerm_CD($lf_user_launcher_term, $(vim_escape_string "$PWD"))"
            vim_remote_call Lf_Popup_EndIgnore
        fi
        lf -remote "send $id quit"
    else
        lf -remote "send $id quit"
    fi
}}
map <a-q> quit

map <a-l> %{{
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call OpenBufExplorer
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}

#>>>

# SELECTION
#<<<
# Track selection.
# Default to primary selection
set user_selection_file "primary_selection"
# Track cursor focus. This is sometimes called "selection" in the docs/discussions, but this is a confusion.
set user_focus_file "primary_focus"

# Workaround for no on-selection-changed.
# (on-select is really "on-focus-cursor-changed", see https://github.com/gokcehan/lf/issues/1332)
cmd on-selection-changed &{{
    &save-selection
}}
map u :unselect; on-selection-changed
map v :invert; on-selection-changed
#map <space> :toggle; down; on-selection-changed
#no moving down
map <space> :toggle; on-selection-changed

#>>>

# RANDOM USEFUL KEYBINDINGS
#<<<

# Play a video file in the background.
map .b ${{
    in_vim || exit
    vim_remote_call Lf_Popup_BeginIgnore
    vim_remote_call execute "tab term ++close mpvbg $(printf '%q' "$f")"
    vim_remote_call Lf_Popup_EndIgnore
    lf -remote "send $id quit"
}}

#>>>

# Source auto-generated config
eval source "$CONFIG_DIR/scripts/syncer_files/syncer-lf"

# Waiting for release 34 for on-init
# Running here for now.
$load-selection
#Don't load the focus automatically, as that would break UX (you want to be newly focused on new lf window).
#$load-focus

map <a--> ${{
    lf_pid="$(ppid $$)"
    vim_remote_call Lf_Split "$OLDPWD" "$PWD" "$f"
}}

#TODO: This is buggy.
# Would prefer an option without using remote calls.
# # Centre the starting selection.
# cmd centre-starting-selection ${{
#     lf -remote "send $id scroll-up"
#     lf -remote "send $id scroll-up"
#     lf -remote "send $id scroll-up"
#     lf -remote "send $id select $(printf '%q' "$f")"
# }}
# :centre-starting-selection
