#!/bin/bash
# readme: Utility for readme files and other software information.
# -d <package_name>: Output README for a package.
# -D <package_name>: Output README.Debian for a package.
# -p No pager
# -m <package_name>: Output man pages for a package.
# -i <package_name>: Information about what is available for this package.

usage ()
{
    local exit_code="$1"
    2>&1 echo "Try 'readme --help' or 'readme -h' for more information."
    exit "$exit_code"
}

func=
func_args=()
set_func ()
{
    local func_name="$1"
    shift
    if [ -n "$func" ]
    then
        usage 1
    fi
    func="$func_name"
    while [ "$#" -gt 0 ]
    do
        func_args+=("$1")
        shift
    done
}

if [ -t 1 ]
then
    if [ ! -z "${PAGER+x}" ]
    then
        #todo: Check, can PAGER contain arguments?
        pager_command="$PAGER"
    else
        pager_command=less
    fi
else
    pager_command=cat
fi

while getopts ":hpd:i:D:m:-:" opt
do
    case $opt in
        h)
            set_func help
            ;;
        d)
            set_func dpkg_readme "$OPTARG"
            ;;
        D)
            set_func dpkg_readme_debian "$OPTARG"
            ;;
        p)
            pager_command=cat
            ;;
        m)
            set_func dpkg_manpages "$OPTARG"
            ;;
        i)
            set_func dpkg_information "$OPTARG"
            ;;
        *)
            case $OPTARG in
                d)
                    [ -n "$func" ] && usage 1 || 2>&1 echo "Usage: -d <package name> "
                    ;;
                D)
                    [ -n "$func" ] && usage 1 || 2>&1 echo "Usage: -D <package name> "
                    ;;
                *)
                    [ -n "$func" ] && usage 1 || 2>&1 echo "Unknown flag -$OPTARG"
                    ;;
            esac
            exit 1
            ;;
    esac
done

[ $OPTIND -eq 1 ] && usage 0

func_help ()
{
    echo "readme:"
    echo "    -d <package_name>: Print debian README file from /usr/share/doc/<package_name>."
    echo "    -D <package_name>: Print debian README.Debian file from /usr/share/doc/<package_name>."
}

do_check_dpkg_installed ()
{
    local package_name="$1"
    if ! dpkg -l "$package_name" >/dev/null 2>&1
    then
        2>&1 echo "error: Package \"$package_name\" is not found."
        return 1
    fi
    if ! dpkg -l "$package_name" 2>/dev/null | tail -1 | grep -q -E '^ii '
    then
        2>&1 echo "error: Package \"$package_name\" is uninstalled."
        return 1
    fi
}

get_dpkg_readme_files ()
{
    local package_name="$1"
    shift
    local extensions=()
    while [ "$#" -gt 0 ]
    do
        extensions+=("$1")
        shift
    done

    do_check_dpkg_installed "$package_name" || return 1

    local package_dir="/usr/share/doc/$package_name"

    for extension in "${extensions[@]}"
    do
        if [ -f "$package_dir/README$extension" ]
        then
            echo "$package_dir/README$extension"
        elif [ -f "$package_dir/README$extension.gz" ]
        then
            echo "$package_dir/README$extension.gz"
        else
            echo "<none>"
        fi
    done
}

dpkg_readme_common ()
{
    local extensions_mode="$1"
    local extensions=()
    [ "$extensions_mode" = "normal" ] && extensions=("" ".md") || extensions=(".Debian")
    local package_name="$2"

    local package_dir="/usr/share/doc/$package_name"
    if [ ! -d "$package_dir" ]
    then
        2>&1 echo "error: Non-existant $package_dir."
        return 1
    fi

    local files="$(get_dpkg_readme_files "$package_name" "${extensions[@]}")"
    local i=0
    while read -r f
    do
        local extension="${extensions[$i]}"
        if [ "$f" != "<none>" ]
        then
            case $(mimetype -b "$f") in
                application/gzip)
                    gunzip -c "$f" | "$pager_command"
                    return 0
                    ;;
                *)
                    cat "$f" | "$pager_command"
                    return 0
                    ;;
            esac
        fi
        ((i++))
    done < <(echo "$files")
    # no readme was found
    for extension in "${extensions[@]}"
    do
        2>&1 echo "error: README$extension file not found in $package_dir"
    done

    return 1
}

func_dpkg_readme ()
{
    dpkg_readme_common normal "$@"
}

func_dpkg_readme_debian ()
{
    dpkg_readme_common debian "$@"
}

func_dpkg_manpages ()
{
    local package_name="$1"

    do_check_dpkg_installed "$package_name" || return 1
    mapfile -t dpkg_manpages_files < <(dpkg -L "$package_name" \
                                        | grep -E '^/usr/share/man/man[[:digit:]]/' \
                                        | xargs -r basename -a \
                                        | sort \
                                        | uniq)

    #note: Not using pager for this output as intended to be copied.
    (
        for i in {1..9}
        do
            local section_manpages=()
            for f in ${dpkg_manpages_files[@]}
            do
                if echo "$f" | grep -q -E '\.'$i'\.gz$'
                then
                    section_manpages+=("$(basename -s .$i.gz "$f")")
                fi
            done
            for var in ${section_manpages[@]}
            do
                echo "$var" | sed "s/^/man $i /"
            done
        done
    )
}

manpage_section_descriptions=(
"<zero section doesn't exist>"
"Executable programs or shell commands"
"System calls (functions provided by the kernel)"
"Library calls (functions within program libraries)"
"Special files (usually found in /dev)"
"File formats and conventions, e.g. /etc/passwd"
"Games"
"Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)"
"System administration commands (usually only for root)"
"Kernel routines [Non standard]"
)

func_dpkg_information ()
{
    local package_name="$1"
    if ! dpkg -l "$package_name" >/dev/null 2>&1
    then
        2>&1 echo "error: Package \"$package_name\" not found."
        return 1
    fi
    echo "name: $package_name"
    dpkg-query --show -f='status: ${Status}\nstatus-abbrev: "${db:Status-Abbrev}"\n' "$package_name"

    local manpages="$(func_dpkg_manpages "$package_name" 2>/dev/null)"
    if [ ! -z "$manpages" ]
    then
        for i in {1..9}
        do
            local section_manpages="$(echo -n "$manpages" | grep -E "^man $i " | cutw 3)"
            if [ ! -z "$section_manpages" ]
            then
                echo "man$i: ${manpage_section_descriptions[$i]}"
                echo "$section_manpages" | while read -r page ; do
                    whatis "$page" | grep -E "^$page \($i\) " | sed 's/^/    /'
                done
            fi
        done
    fi
    printf "README files: "
    get_dpkg_readme_files "$package_name" '' '.md' | grep -v -E '^<none>$' | head -1
    printf "README.Debian file: "
    get_dpkg_readme_files "$package_name" '.Debian' | grep -v -E '^<none>$' | head -1
}

func_$func "${func_args[@]}"
