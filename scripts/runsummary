#!/bin/bash
# runsummary: Run a command with a prefix and postfix summary.
#
#TODO:
#    Counting both stdout and stderr while telling the process
#    it is running on a terminal, so colours are correct.
#    unbuffer can be used, but this combines the streams.

stat ()
{
    stat_heading_width=10
    printf '%'$stat_heading_width's ' "$1"
    #printf '\033[4m%'$stat_heading_width's\033[0m ' "$1"
}

stat command
echo "$@"
stat date
date_string()
{
    date +"%H:%M:%S %-d/%-m/%y"
}
start_date="$(date_string)"
echo "$start_date"

printf '\033[4m%80s\033[0m\n' "_._._._"

RED_UNDERLINE='\033[31;4m'
NC='\033[0m' # no color / reset

tmp_time="$(mktemp)"
tmp_stdout="$(mktemp)"
tmp_stderr="$(mktemp)"

# cmd=(command time -p --output="$tmp_time" "$@")
# echo bash -c \""$(printf '%q ' "${cmd[@]}")"\"
# bash -c "$(printf '%q ' "${cmd[@]}")" > >(tee "$tmp_stdout") 2> >(tee "$tmp_stderr" >&2)
        
unbuffer time -p --output="$tmp_time" "$@" \
    > >(tee "$tmp_stdout") \
    2> >(tee "$tmp_stderr" >&2)
    # 2> >(tee "$tmp_stderr" >&2 | \
    #     while IFS= read -r line; do
    #         #echo -e "${RED_UNDERLINE}${line}${NC}"
    #         echo -e "${RED_UNDERLINE}**${NC} ${line}"
    #         echo "$line" >> stderr.log
    #     done)
error_code="$?"

printf '\033[4m%80s\033[0m\n' ".._._._"

error_summary "$error_code"
stat command
echo "$@"
if [ -f "$tmp_time" ]
then
    seconds="$(cat "$tmp_time" | grep ^real | awk '{print $2}')"
    stat seconds
    echo "$seconds"
    rm "$tmp_time"
else
    echo "[timing failed]"
fi
stat start_date
echo "$start_date"
stat end_date
echo "$(date_string)"

num_stdout_lines="$(wc -l < "$tmp_stdout")"
stat stdout
printf '%s lines\n' "$num_stdout_lines"
num_stderr_lines="$(wc -l < "$tmp_stderr")"
if [ "$num_stderr_lines" -gt 0 ]
then
    stat stderr
    printf '%s lines\n' "$num_stderr_lines"
fi
if [ -f "$tmp_stdout" ]
then
    rm "$tmp_stdout"
fi
if [ -f "$tmp_stderr" ]
then
    rm "$tmp_stderr"
fi
