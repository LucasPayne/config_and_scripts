#!/bin/bash

if [ -z "$VIMSHELL_ID" ] ; then
    echo "Not in a vimshell."
    exit 1
fi

# option: Suppress reading stdin.
# note: Sometimes an application invoking this script will set it up with an empty stdin (lf bug?),
#       so --nostdin needs to be given explicitly.
opt_nostdin=0
# option: Tell the vimshell to cd to the current working directory.
opt_cd=0
# option: Go to line in each file (most useful with just one file).
opt_line=0
# option: Interpret stdin as a list of files to open in new tabs.
opt_filelist=0
# option: Interpret filenames instead as command names, and attempt to edit the corresponding script.
opt_open_scripts=0

files=()
while [[ $# -gt 0 ]]; do
    case $1 in
    --nostdin)
        opt_nostdin=1
        shift
        ;;
    -c|--cd)
        opt_cd=1
        shift
        ;;
    -l|--line)
        shift
        opt_line="$1"
        shift
        ;;
    -f|--filelist)
        opt_filelist=1
        shift
        ;;
    -s|--scripts)
        opt_open_scripts=1
        shift
        ;;
    *)
        files+=("$1")
        shift
        ;;
    esac
done

unsigned_integer_regex='^[0-9]+$'
if ! [[ $opt_line =~ $unsigned_integer_regex ]] ; then
    echo "error: Line number given is not valid" >&2
    exit 1
fi

# Check if accepting and receiving stdin.
if [[ $opt_nostdin -ne 1 ]] ; then
    if [ ! -t 0 ] ; then
        if [[ $opt_filelist -eq 1 ]] ; then
            # Interpret stdin as a list of files to open in new tabs.
            while read -r line ; do
                files+=("$line")
            done
        else
            # Open a temporary file from stdin.
            temporary_filename=$(tempfile 2>/dev/null)
            cat > $temporary_filename
            files+=("$temporary_filename")
        fi
    fi
fi

# Optionally tell the vimshell to cd to the current working directory.
if [[ $opt_cd -eq 1 ]] ; then
    vim --servername "$VIMSHELL_ID" --remote-send '<C-w>:cd '"$(pwd)"'<cr>'
fi

# Send the necessary commands to the vimshell.
for file in ${files[*]} ; do
    if [[ $opt_open_scripts -eq 1 ]] ; then
        # Each "file" is actually a command name.
        # Attempt to find a corresponding script file for the command.
        path="$(which "$file")"
        if [[ $? -ne 0 ]] ; then
            continue
        fi 
        # Just in case, possibly not needed.
        path="$(realpath "$path")"
    else
        # Use the full file path. This means no matter what directory vim is working in,
        # the file specified in the command is opened.
        # It is expected that files referenced in the shell are relative to the shell working directory.
        # It would be unintuitive to specify paths in shell which are meant to be interpreted in vim's working directory.
        path="$(realpath "$file")"
    fi
    vim --servername "$VIMSHELL_ID" --remote-send '<C-w>:tabnew '"$path"'<cr>:silent! normal! '"$opt_line"'ggzOzz<cr>'
done
