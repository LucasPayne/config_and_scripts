#!/bin/bash

# TODO: Instead, open in a new vim and do the equivalent of the sent commands.
if [ -z "$VIM_SERVERNAME" ]
then
    echo "Not in a vim server."
    exit 1
fi

# option: Suppress reading stdin.
# note: Sometimes an application invoking this script will set it up with an empty stdin (lf bug?),
#       so --nostdin needs to be given explicitly.
opt_nostdin=0
# option: Tell the vim server to cd to the current working directory.
opt_cd=0
# option: Go to line in each file (most useful with just one file).
opt_line=0
# option: Interpret stdin as a list of files to open in new tabs.
opt_filelist=0
# option: When parsing file names, parse appended line number.
opt_filelist_lines=0
# option: Interpret filenames instead as command names, and attempt to edit the corresponding script.
opt_open_scripts=0
# option: Load the files into the quickfix list.
opt_quickfix=0
# option: Use the files as the arglist (this works alongside other options).
opt_arglist=0
# option: Regardless of other options, prevent opening files.
opt_no_open=0
# option: Files are urls, use curl.
opt_open_urls=0

files_json="[]"
add_file()
{
    #note: read apparently doesn't like empty entries even if tab separated,
    #        so make sure they are NONE instead.
    local file="$1"
    if [ -z "$file" ] ; then file=NONE ; fi
    local line="$2"
    if [ -z "$line" ] ; then line=NONE ; fi
    local path="$3"
    if [ -z "$path" ] ; then path=NONE ; fi
    #echo "add_file \"$1\" \"$2\" \"$3\""
    files_json="$(echo "$files_json" | jq ". += [{\"file\": \"$file\", \"line\": "$line", \"path\": \"$path\"}]")"
    #echo "$files_json"
}
iterfiles()
{
    jq -r 'to_entries[] | [.value.file, .value.line, .value.path, .key] | @tsv' <<< "$files_json"
}

while [[ $# -gt 0 ]]
do
    case $1 in
    --nostdin)
        opt_nostdin=1
        shift
        ;;
    -c|--cd)
        opt_cd=1
        shift
        ;;
    -l|--line)
        shift
        opt_line="$1"
        shift
        ;;
    -f|--filelist)
        opt_filelist=1
        shift
        ;;
    -F|--filelist-lines)
        opt_filelist=1
        opt_filelist_lines=1
        shift
        ;;
    -s|--scripts)
        opt_open_scripts=1
        shift
        ;;
    -q|--quickfix)
        opt_quickfix=1
        shift
        ;;
    -a|--arglist)
        opt_arglist=1
        shift
        ;;
    -A|--arglist-no-open)
        opt_arglist=1
        opt_no_open=1
        shift
        ;;
    -u|--url)
        opt_open_urls=1
        shift
        ;;
    *)
        add_file "$1" 1 ""
        shift
        ;;
    esac
done

# Handle incompatible flags
if [ $opt_open_urls -eq 1 ] && [ $opt_open_scripts -eq 1 ]
then
    >&2 echo "error: Cannot use -s/--script and -u/--url simultaneously."
    exit 1
fi

#debug
# if false
# then
#     unsigned_integer_regex='^[0-9]+$'
#     if ! [[ $opt_line =~ $unsigned_integer_regex ]]
#     then
#         echo "error: Line number given is not valid" >&2
#         exit 1
#     fi
# fi

# Check if accepting and receiving stdin.
if [[ $opt_nostdin -ne 1 ]]
then
    if [ ! -t 0 ]
    then
        if [[ $opt_filelist -eq 1 ]]
        then
            if [[ $opt_filelist_lines -eq 1 ]]
            then
                # Interpret stdin as a list of files and lines to open in new tabs.
                while read -r input
                do
                    line="${input##* }"
                    file="${input% $line}"
                    add_file "$file" "$line" ""
                done
            else
                # Interpret stdin as a list of files to open in new tabs.
                while read -r input
                do
                    add_file "$input" 1 ""
                done
            fi
        else
            # Open a temporary file from stdin.
            if [[ "$(readlink -f /proc/self/fd/0 2>/dev/null)" = "/dev/null" ]]
            then
                # Don't read from /dev/null.
                # xargs, for example, will launch this script with /dev/null on stdin.
                # (Is there a cleaner/idiomatic way to consider this?)
                :
            else
                temporary_filename=$(tempfile 2>/dev/null)
                cat > "$temporary_filename"
                add_file "$temporary_filename" 1 ""
            fi
        fi
    fi
fi

# Optionally tell the vim server to cd to the current working directory.
if [[ $opt_cd -eq 1 ]]
then
    vim --servername "$VIM_SERVERNAME" --remote-send '<C-\><C-n>:cd '"$(pwd)"'<cr>'
fi

# Determine the paths to be communicated to vim.
while IFS=$'\t' read -r file line path index
do
    if [ $opt_open_scripts -eq 1 ]
    then
        # Each "file" is actually a command name.
        # Attempt to find a corresponding script file for the command.
        path="$(which "$file")"
        if [ $? -eq 0 ]
        then
            # Just in case, possibly not needed.
            path="$(realpath "$path")"
        else
            path=""
        fi
    elif [ $opt_open_urls -eq 1 ]
    then
        # Each "file" is actually a url.
        # Attempt to curl each url.
        mkdir -p /tmp/vim_tmp_curl >/dev/null 2>&1
        if [ $? -eq 0 ]
        then
            tmp="$(mktemp --tmpdir=/tmp/vim_tmp_curl XXXX)"
            curl_output="$(curl -L "$file" 2>/dev/null)"
            if [ $? -eq 0 ]
            then
                echo "$curl_output" > "$tmp"
                path="$tmp"
            else
                rm "$tmp"
                path=""
            fi
        else
            # Note: This error handling is just to be very careful with
            # removing tmp files in case they aren't made.
            path=""
        fi
    else
        # Use the full file path. This means no matter what directory vim is working in,
        # the file specified in the command is opened.
        # It is expected that files referenced in the shell are relative to the shell working directory.
        # It would be unintuitive to specify paths in shell which are meant to be interpreted in vim's working directory.
        path="$(realpath "$file")"
    fi
    files_json=$(echo "$files_json" | jq --arg path "$path" '.['$index'].path = $path')
done < <(iterfiles)

# Send the necessary commands to the vim server.
if [[ $opt_quickfix -eq 1 ]]
then
    json='[]'
    while IFS=$'\t' read -r file line path index
    do
        json="$(echo "$json" | jq ". += [{\"path\": \"$path\", \"line\": "$line", \"column\": 1}]")"
    done < <(iterfiles)
    echo "$json" | vimjsonrpc QuickFixFromJSON
else
    if [[ $opt_no_open -eq 0 ]]
    then
        while IFS=$'\t' read -r file line path index
        do
            if [ "$opt_line" -ne 0 ]
            then
                # Override the line of each file.
                # (opt_line is mainly useful when there is only one file.)
                line="$opt_line"
            fi
            send_string='<C-\><C-n>:tabnew '"$path"'<cr>:silent! normal! '"$line"'ggzOzz<cr>'
            vim --servername "$VIM_SERVERNAME" --remote-send "$send_string"
        done < <(iterfiles)
    fi
fi

if [[ $opt_arglist -eq 1 ]]
then
    # Clear the argument list
    send_string='<C-\><C-n>:%argd<cr>'
    vim --servername "$VIM_SERVERNAME" --remote-send "$send_string"
    # Add the paths to the argument list
    while IFS=$'\t' read -r file line path index
    do
        send_string='<C-\><C-n>:argadd '"$path"'<cr>'
        vim --servername "$VIM_SERVERNAME" --remote-send "$send_string"
    done < <(iterfiles)
fi
