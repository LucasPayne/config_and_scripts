#!/bin/bash
# dirspace_get: Get the name of a dirspace from a path.
# Error code indicates whether the path is a dirspace.

# Option: Get the closest parent dirspace if possible.
#     e.g. if Config is a dirspace at ~/config,
#     then ~/config/scripts will resolve to Config with this option.
option_parent=0
option_force=0
arg_path=
while [ $# -gt 0 ]
do
    case "$1" in
        -p|--parent)
            option_parent=1
            ;;
        -f|--force)
            option_force=1
            ;;
        *)
            if [ ! -z "$arg_path" ]
            then
                >&2 echo "Only one path can be given."
                exit 1
            fi
            arg_path="$1"
    esac
    shift
done
if [ -z "$arg_path" ]
then
    >&2 echo "A path must be given."
    exit 1
fi
# Expand leading ~ to home.
arg_path="${arg_path/#\~/$HOME}"

if [ ! -d "$arg_path" ]
then
    >&2 echo "Not a directory: $arg_path"
    exit 1
fi

# Resolve the path without resolving symbolic links.
input_path="$(
    cd "$arg_path"
    pwd -L
)"

lines="$(cat ~/config/dirspace/dirspaces.txt | grep -v '^#' | grep -v '^\s*$')"
num="$(echo "$lines" | wc -l)"

mapfile -t paths < <(echo "$lines" | awk -F" -- " '{print $1}' | sed 's/^@ //g')
mapfile -t names < <(echo "$lines" | awk -F" -- " '{print $2}')

function match_path()
{
    local path="$1"
    if [ ! -d "$path" ]
    then
        # Skip silently.
        return 1
    fi
    path="$(realpath "$path")"
    if [ $option_parent -eq 1 ]
    then
        [[ "$input_path/" =~ ^$path/ ]]
        return $?
    else
        test "$path" = "$input_path"
        return $?
    fi
}

longest_pathlen=-1
longest_path=
name=""
for ((i=0 ; i<num; i++))
do
    path="${paths[i]}"
    # Expand the leading ~ if there.
    path="${path/#\~/$HOME}"

    if echo "$path" | grep -q "/{}$" 2>/dev/null
    then
        expanding_path="${path::-2}"
        if [ ! -d "$expanding_path" ]
        then
            # Skip silently.
            continue  path
        fi
        while read -r path
        do
            if match_path "$path"
            then
                pathlen=${#path}
                if [ $pathlen -gt $longest_pathlen ]
                then
                    longest_pathlen=$pathlen
                    longest_path="$path"
                    subdir="$(basename "$path")"
                    expanding_name="${names[i]}"
                    expanding_name="${expanding_name//\{\}/$subdir}"
                    expanding_name="${expanding_name//\{capitalize\}/${subdir^}}"
                    expanding_name="${expanding_name//\{upper\}/${subdir^^}}"
                    expanding_name="${expanding_name//\{lower\}/${subdir,,}}"
                    name="$expanding_name"
                fi
            fi
        done < <(fd -I . -td -d1 "$expanding_path")
    else
        if match_path "$path"
        then
            pathlen=${#path}
            if [ $pathlen -gt $longest_pathlen ]
            then
                longest_pathlen=$pathlen
                longest_path="$path"
                name="${names[i]}"
            fi
        fi
    fi
done

if [ $longest_pathlen -ge 0 ]
then
    printf '%s -- %s\n' "$name" "$longest_path"
    exit 0
fi

if [ $option_force -eq 1 ]
then
    printf '%s -- %s\n' "$input_path" "$input_path"
    exit 0
fi

# Dirspace not found
# Fail.
exit 1
