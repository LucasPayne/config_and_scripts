#!/bin/bash
# dirspace_launcher:
#

error ()
{
    >&2 echo "$1"
    exit 1
}

session_name_postfix="dirspace"

# Make sure runtime (xdg share) directories are available.
RUNTIME_DIR=~"/.local/share/dirspace"
if [ ! -d "$RUNTIME_DIR" ]
then
    mkdir -p "$RUNTIME_DIR" 2>/dev/null || error "Failed to create dirspace runtime directory."
fi
FIFOS_DIR="$RUNTIME_DIR/fifos"
if [ ! -d "$FIFOS_DIR" ]
then
    mkdir -p "$FIFOS_DIR" 2>/dev/null || error "Failed to create dirspace fifos directory."
fi
#--Maybe scan for dead fifos, with fuser.

# Create a named pipe (FIFO).
FIFO="$(mktemp --tmpdir "$FIFOS_DIR" XXXXXX)"
if [[ ! -p "$FIFO" ]]
then
    mkfifo "$FIFO" || error "Failed to create FIFO."
fi

# -D: Don't attach and don't fork the daemon.
#     The screen session will run as a job in this script.
#     (This is the easiest way to get its PID.)
# -m: Create even if STY exists (e.g. in a screen session).
#screen -D -m -S "$session_name_postfix" -c ~/config/dirspace/dirspace_screenrc &
screen -D -m -S "$session_name_postfix" &
screen_pid=$!
session_name="$screen_pid.$session_name_postfix"
echo "$screen_pid"
echo "$session_name"

# Wait for the new screen session.
while ! (screen -ls | grep -q "$session_name")
do
    sleep 0.1
done

# Helper function to send a command to the session.
call ()
{
    screen -S "$session_name" "$@"
}

get_current_window ()
{
    call -Q number | tr -d' ' -f 1 
}

# Create a dirspace screen window.
create_dirspace ()
{
    dirspace_path="$1"
    dirspace_name="$(dirspace_get "$dirspace_path")"
    if [ $? -ne ]
    then
        dirspace_name="$dirspace_path"
    fi
    call -X screen -t "$dirspace_name" bash -c "cd $(printf '%q' "$dirspace_path") ; exec ~/config/dirspace/dirspace_vim"
}

# Create a window.
create_dirspace ~/notes/notes.d
# Delete the initial window.
call -p 0 -X kill
call -p 1 -X number 0

create_dirspace ~/config
create_dirspace ~/drive/dev/academia
create_dirspace ~/code/cg_sandbox

# Create a terminal emulator to run screen as controlling process,
# and attach to the session.
d cool-retro-term -e screen -r "$session_name"

# Wait until the emulator has attached the session.
while ! (screen -ls | grep "$session_name" | grep -q "Attached")
do
    sleep 0.1
done

# # Select the first window.
# # (Apparently this requires the session to be already attached.)
# sleep 2
# call -p 0 -X select

# Act as a RCP server.

# Wait for screen session to die.
#--
# Delete FIFO.
#--
