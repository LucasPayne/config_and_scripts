#!/bin/bash
# dirspace_launcher:
#

error ()
{
    >&2 echo "$1"
    exit 1
}

screen_name_postfix="dirspace"

# Make sure runtime (xdg share) directories are available.
RUNTIME_DIR=~"/.local/share/dirspace"
if [ ! -d "$RUNTIME_DIR" ]
then
    mkdir -p "$RUNTIME_DIR" 2>/dev/null || error "Failed to create dirspace runtime directory."
fi
FIFOS_DIR="$RUNTIME_DIR/fifos"
if [ ! -d "$FIFOS_DIR" ]
then
    mkdir -p "$FIFOS_DIR" 2>/dev/null || error "Failed to create dirspace fifos directory."
fi
#--Maybe scan for dead fifos, with fuser.

# Create a named pipe (FIFO).
FIFO="$(mktemp --tmpdir="$FIFOS_DIR" XXXX)"
if [[ ! -f "$FIFO" ]]
then
    error "Failed to create FIFO."
fi
rm "$FIFO"
mkfifo "$FIFO" || error "Failed to create FIFO."

DIRSPACE_SESSION_ID="$(basename "$FIFO")"

# -D: Don't attach and don't fork the daemon.
#     The screen session will run as a job in this script.
#     (This is the easiest way to get its PID.)
# -m: Create even if STY exists (e.g. in a screen session).
DIRSPACE_SESSION_ID="$DIRSPACE_SESSION_ID" screen -D -m -S "$screen_name_postfix" &
screen_pid=$!
screen_name="$screen_pid.$screen_name_postfix"
echo "$screen_pid"
echo "$screen_name"

# Wait for the new screen session.
while ! (screen -ls | grep -q "$screen_name")
do
    sleep 0.1
done

# Helper function to send a command to the session.
call ()
{
    screen -S "$screen_name" "$@"
}

get_current_window ()
{
    call -Q number | tr -d' ' -f 1 
}

# Create a dirspace screen window.
create_dirspace ()
{
    dirspace_path="$1"
    dirspace_name="$(dirspace_get "$dirspace_path")"
    if [ $? -ne ]
    then
        dirspace_name="$dirspace_path"
    fi
    call -X screen -t "$dirspace_name" bash -c "cd $(printf '%q' "$dirspace_path") ; exec ~/config/dirspace/dirspace_vim"
}

# Create a window.
create_dirspace ~/notes/notes.d
# Delete the initial window.
call -p 0 -X kill
call -p 1 -X number 0

create_dirspace ~/config
create_dirspace ~/drive/dev/academia
create_dirspace ~/code/cg_sandbox

# Create a terminal emulator to run screen as controlling process,
# and attach to the session.
d cool-retro-term -e screen -r "$screen_name"

# Wait until the emulator has attached the session.
while ! (screen -ls | grep "$screen_name" | grep -q "Attached")
do
    sleep 0.1
done

# Act as a RCP server.

RCP_func ()
{
    echo "$1" | tr o e
}

# Run forever, reading lines
while true
do
    if read line < "$FIFO"
    then
        cmd=( $line )
        fn="${cmd[0]}"
        args=( "${cmd[@]:1}" )
        if declare -F "RCP_$fn" >/dev/null; then
            "RCP_$fn" "${args[@]}"
        else
            echo "Unknown function: $fn"
        fi
    fi
done

# # Select the first window.
# # (Apparently this requires the session to be already attached.)
# sleep 2
# call -p 0 -X select

# Wait for screen session to die.
#--
# Delete FIFO.
#--

#screen -D -m -S "$screen_name_postfix" -c ~/config/dirspace/dirspace_screenrc &
